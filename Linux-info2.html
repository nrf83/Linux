<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <title>Linux</title>
    <h2><a href="Linux-info.html">1</a><h2>
    <h2><a href="Linux-info3.html">3</a><h2>
    
</head>
<body>
    <h1 style="color: blue;">Linux<h2>
    <p><h3 style="color: rgb(12, 178, 18);">Graphical Interface</h3></p><hr>
    <p>
        <h3 style="color: rgb(12,178,18);">Chapter 7: Command Line Operations</h3>
    </p>
    <p>
        <pre>
        <h2> Terminal on the Graphical Desktop</h2>
        By default, on GNOME desktop environments, the gnome-terminal application is used to emulate a text-mode terminal in a window. 
        Other available terminal programs include:
    
                xterm
                konsole (default on KDE)
                terminator
    
        </pre><hr>
    </p>
    
      <p>
        <pre>
          <h2>Basic Utilities</h2>
      
      
          <b>cat</b>: used to type out a file (or combine files).
          <b>head</b>: used to show the first few lines of a file.
          <b>tail</b>: used to show the last few lines of a file.
          <b>man</b>: used to view documentation.
      
      
      <img src="images/cmdutils.png">
        
        </pre>
      </p><hr>
      
      <p>
        <pre>
          <h2>Command Line</h2>
      
      
      
      Most input lines entered at the shell prompt have three basic elements:
      
      Command
      Options
      Arguments
      
      The command is the name of the program you are executing. It may be followed by one or more options (or switches) that modify what the command may do. 
      Options usually start with one or two dashes, for example, -p or --print, in order to differentiate them from arguments, which represent what the command operates on.
      
      However, plenty of commands have no options, no arguments, or neither. 
      In addition, other elements (such as setting environment variables) can also appear on the command line when launching a task.
      
        </pre>
      </p><hr>
      
      <p>
        <pre>
          <h2>sudo</h2>
          All the demonstrations created have a user configured with sudo capabilities to provide the user with administrative (admin) privileges when required. 
          sudo allows users to run programs using the security privileges of another user, generally root (superuser). 
      
          On your own systems, you may need to set up and enable sudo to work correctly. 
          To do this, you need to follow some steps that we will not explain in much detail now, but you will learn about later in this course. When running on Ubuntu and some other recent distributions, 
          sudo is already always set up for you during installation. On other Linux distributions, you will likely need to set up sudo to work properly for you after the initial installation.
          
          Next, you will learn the steps to set up and run sudo on your system
          <img src="images/sudosuse.png">
        </pre>
      </p><hr>
      
      <p>
        <pre>
          <h2>Steps for Setting Up and Running sudo</h2>
      
          If your system does not already have sudo set up and enabled, you need to do the following steps:
      
                1.You will need to make modifications as the administrative, or superuser, root. While sudo will become the preferred method of doing this, 
                  we do not have it set up yet, so we will use su (which we will discuss later in detail) instead. At the command line prompt, type su and press Enter. 
                  You will then be prompted for the root password, so enter it and press Enter. You will notice that nothing is printed; this is so others cannot see the password on the screen. 
                  You should end up with a different looking prompt, often ending with ‘#’. For example:
                  $ su Password:
                  #
                2.Now, you need to create a configuration file to enable your user account to use sudo. Typically, this file is created in the /etc/sudoers.d/ directory with the name of the file the same as your username. 
                  For example, for this demo, let’s say your username is student. After doing step 1, you would then create the configuration file for student by doing this:
                  # echo "student ALL=(ALL) ALL" > /etc/sudoers.d/student
                3.Finally, some Linux distributions will complain if you do not also change permissions on the file by doing:
                  # chmod 440 /etc/sudoers.d/student
      
      That should be it. For the rest of this course, if you use sudo you should be properly set up. 
      When using sudo, by default you will be prompted to give a password (your own user password) at least the first time you do it within a specified time interval. 
      It is possible (though very insecure) to configure sudo to not require a password or change the time window in which the password does not have to be repeated with every sudo command.
        </pre>
      </p><hr>
      
      <p>
        <pre>
          <h2>Switching Between the GUI and the Command Line</h2>
          The customizable nature of Linux allows you to drop the graphical interface (temporarily or permanently) or to start it up after the system has been running.
      
      Most Linux distributions give an option during installation (or have more than one version of the install media) to choose between desktop (with a graphical desktop) and server (usually without one).
      
      Linux production servers are usually installed without the GUI, and even if it is installed, usually do not launch it during system startup. 
      Removing the graphical interface from a production server can be very helpful in maintaining a lean system, which can be easier to support and keep secure.
        
      <img src="images/debianterminal.png">
      </pre>
      </p><hr>
      
      <p>
        <pre>
          <h2>Virtual Terminals</h2>
      
          Virtual Terminals (VT) are console sessions that use the entire display and keyboard outside of a graphical environment. 
          Such terminals are considered "virtual" because, although there can be multiple active terminals, only one terminal remains visible at a time. 
          A VT is not quite the same as a command line terminal window; you can have many of those visible at once on a graphical desktop.
      
          One virtual terminal (usually number one or seven) is reserved for the graphical environment, and text logins are enabled on the unused VTs. 
          Ubuntu uses VT 7, but CentOS/RHEL and openSUSE use VT 1 for the graphical display.
          
          An example of a situation where using VTs is helpful is when you run into problems with the graphical desktop. 
          In this situation, you can switch to one of the text VTs and troubleshoot.
          
          To switch between VTs, press CTRL-ALT-function key for the VT. For example, press CTRL-ALT-F6 for VT 6. 
          Actually, you only have to press the ALT-F6 key combination if you are in a VT and want to switch to another VT.
          
          <img src="images/LFS01_ch06_screen07.jpg"> 
        </pre>
      </p>
      
      <p>
        <pre>
          <h2>Turning Off the Graphical Desktop</h2>
      
          Linux distributions can start and stop the graphical desktop in various ways. 
          The exact method differs from distribution and among distribution versions. For the newer systemd-based distributions, 
          the display manager is run as a service, you can stop the GUI desktop with the systemctl utility and most distributions will also work with the telinit command, as in:
      
      $ sudo systemctl stop gdm (or sudo telinit 3)
      
      and restart it (after logging into the console) with:
      
      $ sudo systemctl start gdm (or sudo telinit 5)
      
      On Ubuntu versions before 18.04 LTS, substitute lightdm for gdm.
      
      <img src="images/console.png">
      
        </pre>
      </p>
      <p><hr>
        <pre>
          <h2>Killing the Graphical User Interface</h2>



Methods of bringing down the GUI:

student:/tmp> sudo systemctl stop gdm
student:/tmp> sudo systemctl stop lightdm
student:/tmp> sudo telinit 3

Methods of bringing the GUI back up:

student:/tmp> sudo systemctl start gdm
student:/tmp> sudo systemctl start lightdm
student:/tmp> sudo telinit 5

        </pre>
      </p><hr>

<p>
  <pre>
    <h2>Basic Operations</h2>
    <img src="images/LFS01_ch06_screen11.jpg">
  </pre>
</p><hr>

<p>
  <pre>
    <h2>logginng in and Out</h2>
    An available text terminal will prompt for a username (with the string login:) and password. When typing your password, 
    nothing is displayed on the terminal (not even a * to indicate that you typed in something), to prevent others from seeing your password. 
    After you have logged into the system, you can perform basic operations.

Once your session is started (either by logging into a text terminal or via a graphical terminal program), you can also connect and log into remote systems by using Secure SHell (SSH). 
For example, by typing ssh student@remote-server.com, 
SSH would connect securely to the remote machine (remote-server.com) and give student a command line terminal window, 
using either a password (as with regular logins) or cryptographic key to sign in without providing a password to verify the identity.
  
<img src="images/ubuntulogin.png">
</pre>
</p><hr>

<p>
  <pre>
    <h2>Rebooting and Shutting Down</h2>

    The preferred method to shut down or reboot the system is to use the shutdown command. This sends a warning message, and then prevents further users from logging in. 
    The init process will then control shutting down or rebooting the system. It is important to always shut down properly; failure to do so can result in damage to the system and/or loss of data.

The halt and poweroff commands issue shutdown -h to halt the system; reboot issues shutdown -r and causes the machine to reboot instead of just shutting down. 
Both rebooting and shutting down from the command line requires superuser (root) access.

When administering a multi-user system, you have the option of notifying all users prior to shutdown, as in:

$ sudo shutdown -h 10:00 "Shutting down for scheduled maintenance."

NOTE: On recent Wayland-based Linux distributions, broadcast messages do not appear on terminal emulation sessions running on the desktop; they appear only on the VT console displays.
  
<img src="images/ubuntushutdown.png">
</pre>
</p><hr>

<p>
  <pre>
    <h2>Locating Applications</h2>

    Depending on the specifics of your particular distribution's policy, programs and software packages can be installed in various directories. 
    In general, executable programs and scripts should live in the /bin, /usr/bin, /sbin, /usr/sbin directories, or somewhere under /opt. 
    They can also appear in /usr/local/bin and /usr/local/sbin, or in a directory in a user's account space, such as /home/student/bin.

One way to locate programs is to employ the which utility. For example, to find out exactly where the diff program resides on the filesystem:

$ which diff
/usr/bin/diff

If which does not find the program, whereis is a good alternative because it looks for packages in a broader range of system directories:

$ whereis diff
diff: /usr/bin/diff /usr/share/man/man1/diff.1.gz /usr/share/man/man1p/diff.1p.gz

as well as locating source and man files packaged with the program.

<img src="images/whereis.png">
  </pre>
</p><hr>

<p>
  <pre>
    <h2>Accessing Directories</h2>
    When you first log into a system or open a terminal, the default directory should be your home directory. 
    You can print the exact path of this by typing echo $HOME. Many Linux distributions actually open new graphical terminals in $HOME/Desktop. 
    The following commands are useful for directory navigation:

    Command 	          Result
pwd 	                  Displays the present working directory
cd ~ or cd 	            Change to your home directory (shortcut name is ~ (tilde))
cd .. 	                Change to parent directory (..)
cd - 	                  Change to previous directory (- (minus))
  
<video width="1000" controls><source src="images/41e9ceca-8aa4-4b08-8afc-8162da7ce91d-mp4_720p.mp4"></video>

Tasks to be performed:

    Locate the application titled "gcc" using whereis command.
    Display the present working directory.
    Change the current working directory to /usr/bin .
    Change the current working directory to /home/student .
    Move to the parent directory.
    Go to the previous directory by the shortcut method i.e using '-' operator.
    Display the present working directory.

<h5>   Tasks to be performed:

    1.Locate the application titled "gcc" using <em>whereis</em> command.
    2.Display the present working directory.
    3.Change the current working directory to <em>/usr/bin</em> .
    4.Change the current working directory to <em>/home/student</em> .
    5.Move to the parent directory.
    6.Go to the previous directory by the shortcut method i.e using '-' operator.
    7.Display the present working directory.</h5>

1.
student:/tmp> whereis gcc
gcc: /usr/bin/gcc /usr/lib/gcc /usr/libexec/gcc /usr/lib64/ccache/gcc /usr/share/man/man1/gcc.1.gz
student:/tmp>
2.
student:/tmp> pwd
student:/tmp>
student:/tmp>
3.
student:/tmp> cd /usr/bin
student:/usr/bin> 
4.
student:/usr/bin> cd
student:/home/student> 
5.
student:/home/student> cd ..
student:/home> 
6.
student:/home> cd -
/home/student
student:/home/student> 
7.
student:/home> pwd
/home/student
student:/home/student> 

</pre>
</p><hr>

<p>
  <pre>
    <h2>Understanding Absolute and Relative Paths</h2>

    There are two ways to identify paths:

            Absolute pathname
            An absolute pathname begins with the root directory and follows the tree, branch by branch, until it reaches the desired directory or file. 
            Absolute paths always start with /.
            Relative pathname
            A relative pathname starts from the present working directory. Relative paths never start with /.

Multiple slashes (/) between directories and files are allowed, but all but one slash between elements in the pathname is ignored by the system.
 ////usr//bin is valid, but seen as /usr/bin by the system.

Most of the time, it is most convenient to use relative paths, which require less typing. 
Usually, you take advantage of the shortcuts provided by: . (present directory), .. (parent directory) and ~ (your home directory).

For example, suppose you are currently working in your home directory and wish to move to the /usr/bin directory. 
The following two ways will bring you to the same directory from your home directory:

            Absolute pathname method
            $ cd /usr/bin
            Relative pathname method
            $ cd ../../usr/bin

In this case, the absolute pathname method requires less typing.

<img src="images/LFS01_ch06_screen19.jpg">
  </pre>
</p>
<p>
  <pre>
  <h2>Exploring the Filesystem</h2>
  Traversing up and down the filesystem tree can get tedious. 
  The <b>tree</b> command is a good way to get a bird’s-eye view of the filesystem tree. 
  Use <b>tree -d</b> to view just the directories and to suppress listing file names.
  <img
  src="images/tree-d.png">


Command 	Usage
cd / 	            Changes your current directory to the root (/) directory (or path you supply)
ls 	              List the contents of the present working directory
ls –a 	          List all files, including hidden files and directories (those whose name start with . )
tree 	            Displays a tree view of the filesystem

<video width="1000" controls><source src="images/Exploring the Filesystem.mp4"></video>
  </pre>
</p><hr>

<p>
  <pre>
<h2>Hard Links</h2>
The ln utility is used to create hard links and (with the -s option) soft links, also known as symbolic links or symlinks. These two kinds of links are very useful in UNIX-based operating systems.

Suppose that file1 already exists. A hard link, called file2, is created with the command:

$ ln file1 file2

Note that two files now appear to exist. However, a closer inspection of the file listing shows that this is not quite true.

$ ls -li file1 file2

The -i option to ls prints out in the first column the inode number, which is a unique quantity for each file object. 
This field is the same for both of these files; what is really going on here is that it is only one file, 
but it has more than one name associated with it, as is indicated by the 2 that appears in the ls output. 
Thus, there was already another object linked to file1 before the command was executed.

Hard links are very useful and they save space, but you have to be careful with their use, sometimes in subtle ways. 
For one thing, if you remove either file1 or file2 in the example, the inode object (and the remaining file name) will remain, 
which might be undesirable, as it may lead to subtle errors later if you recreate a file of that name.

If you edit one of the files, exactly what happens depends on your editor; most editors, including vi and gedit, 
will retain the link by default, but it is possible that modifying one of the names may break the link and result in the creation of two objects.

<img src="images/lnubuntu.png">

  </pre>
</p><hr>
<p>
  <pre>
    <h2>Soft (Symbolic) Links</h2>
    Soft (or Symbolic) links are created with the -s option, as in:

$ ln -s file1 file3
$ ls -li file1 file3

Notice file3 no longer appears to be a regular file, and it clearly points to file1 and has a different inode number.

Symbolic links take no extra space on the filesystem (unless their names are very long). They are extremely convenient, as they can easily be modified to point to different places. 
An easy way to create a shortcut from your home directory to long pathnames is to create a symbolic link.

Unlike hard links, soft links can point to objects even on different filesystems, partitions, and/or disks and other media, which may or may not be currently available or even exist. 
In the case where the link does not point to a currently available or existing object, you obtain a dangling link.
<img src="images/lnsubuntu.png">
  </pre>
</p><hr>

<p>
  <pre>
    <h2>Navigating the Directory History</h2>
    The cd command remembers where you were last, and lets you get back there with cd -. 
    For remembering more than just the last directory visited, use pushd to change the directory instead of cd; this pushes your starting directory onto a list. 
    Using popd will then send you back to those directories, walking in reverse order (the most recent directory will be the first one retrieved with popd). 
    The list of directories is displayed with the dirs command.
    <img src="images/pushdfedora.png">
    <video width="1000" controls><source src="images/89eb42ec-3c89-4dec-8b73-c9b890c88d9f-mp4_720p.mp4"></video>
  </pre>
</p><hr>

<p>
  <pre>
    <h2>Locating Applications</h2>



student:/tmp> which ip
/usr/sbin/ip

student:/tmp> whereis ip
ip: /usr/sbin/ip /usr/share/man/man7/ip.7.gz /usr/share/man/man8/ip.8.gz      

Note whereis also reports the location of the man page.

  </pre>
</p><hr>

<p>
  <pre>
    <h2>Viewing Files</h2>

Command 	Usage
cat 	Used for viewing files that are not very long; it does not provide any scroll-back.
tac 	Used to look at a file backwards, starting with the last line.
less 	Used to view larger files because it is a paging program. It pauses at each screen full of text, provides scroll-back capabilities, and lets you search and navigate within the file.

NOTE: Use / to search for a pattern in the forward direction and ? for a pattern in the backward direction. An older program named more is still used, but has fewer capabilities: "less is more".
tail 	Used to print the last 10 lines of a file by default. You can change the number of lines by doing -n 15 or just -15 if you wanted to look at the last 15 lines instead of the default.
head 	The opposite of tail; by default, it prints the first 10 lines of a file.
  
<video width="1000" controls><source src="images/6244a0ed-8260-4df0-bbee-553dae259d64-mp4_720p(1).mp4"></video>
</pre>
</p><hr>


<p>
  <pre>
    <h2>touch</h2>
    touch is often used to set or update the access, change, and modify times of files. 
    By default, it resets a file's timestamp to match the current time.

However, you can also create an empty file using touch:

$ touch -filename-

This is normally done to create an empty file as a placeholder for a later purpose.

touch provides several useful options. For example, the -t option allows you to set the date and timestamp of the file to a specific value, as in:

$ touch -t 12091600 myfile

This sets the myfile file's timestamp to 4 p.m., December 9th (12 09 1600).

<img src="images/touch.png">
  </pre>
</p><hr>

<p>
  <pre>
    <h2>mkdir and rmdir</h2>

    mkdir is used to create a directory:

            mkdir sampdir 
            It creates a sample directory named sampdir under the current directory. 
            mkdir /usr/sampdir 
            It creates a sample directory called sampdir under /usr.

Removing a directory is done with rmdir. The directory must be empty or the command will fail. 
To remove a directory and all of its contents you have to do rm -rf.

<img src="images/mkdir.png">
  </pre>
</p><hr>


<p>
  <pre>
    <h2>Moving, Renaming or Removing a File</h2>

    Note that mv does double duty, in that it can:

            Simply rename a file
            Move a file to another location, while possibly changing its name at the same time.

If you are not certain about removing files that match a pattern you supply, 
it is always good to run rm interactively (rm –i) to prompt before every removal.



Command 	    Usage
mv 	          Rename a file 
rm 	          Remove a file 
rm –f 	      Forcefully remove a file
rm –i 	      Interactively remove a file

  </pre>
</p><hr>

<p>
  <pre>
    <h2>Renaming or Removing a Directory</h2>

    rmdir works only on empty directories; otherwise you get an error. 

    While typing rm –rf is a fast and easy way to remove a whole filesystem tree recursively, 
    it is extremely dangerous and should be used with the utmost care, 
    especially when used by root (recall that recursive means drilling down through all sub-directories, all the way down a tree).

    Command 	      Usage
mv 	                Rename a directory
rmdir 	            Remove an empty directory
rm -rf 	            Forcefully remove a directory recursively
  </pre>
</p><hr>



<p>
  <pre>
    <h2>Modifying the Command Line Prompt</h2>

    The PS1 variable is the character string that is displayed as the prompt on the command line. 
    Most distributions set PS1 to a known default value, which is suitable in most cases. 
    However, users may want custom information to show on the command line. 
    For example, some system administrators require the user and the host system name to show up on the command line as in:

    student@c8 $
    
    This could prove useful if you are working in multiple roles and want to be always reminded of who you are and what machine you are on. 
    The prompt above could be implemented by setting the PS1 variable to: \u@\h \$.
    
    For example:
    
    $ echo $PS1
    \$
    $ PS1="\u@\h \$ "
    student@c8 $ echo $PS1
    \u@\h \$
    student@c8 $
    
    By convention, most systems are set up so that the root user has a pound sign (#) as their prompt.

    <video width="1000" controls><source src="images/0a2c05cb-7749-4c31-b351-8c1cc7791859-mp4_720p.mp4"></video>


    Tasks to be performed:

    <ol>
    <li>Using touch, create file1 and file2 (two empty files)</li>
    <li>Check for the existence of file1 and file2 using ls -l .</li>
    <li>Rename file1 to new_file1 using mv.</li>
    <li>Remove file2 using rm without any options.</li>
    <li>Remove new_file1 using rm without any options.</li>
    <li>Create a directory named dir1, using mkdir.</li>
    <li>Remove dir1 using rmdir without any options.</li>
    </ol>


    <ol>
      <li></li>
      student:/tmp> touch file1 file2
      student:/tmp>
      
      <li></li>
      student:/tmp> ls -l file1 file2
      -rw-r--r--. 	1 	file1 	file1 	0 	Sep 11 2021 	file1
      -rw-r--r--. 	1 	file1 	file1 	0 	Sep 11 2021 	file2
      student:/tmp>
      <li></li>
      student:/tmp> mv file1 new_file1
      student:/tmp>
      <li></li>
      student:/tmp> rm file2
      student:/tmp> 
      <li></li>
      student:/tmp> rm new_file1
      student:/tmp>
      <li></li>
      student:/tmp> mkdir dir1
      student:/tmp>
      <li></li>student:/tmp> rmdir dir1
      student:/tmp>

    </ol>

  </pre>
</p><hr>



<p>
  <pre>
    <h2>Creating, Moving and Removing Files</h2>
    Create an empty file named exercise.txt and move this file to the /tmp directory, using a relative pathname from your home directory. 
    Then, delete this file using an absolute pathname.



student:/home/student> touch exercise.txt
student:/home/student> mv exercise.txt ../../tmp
student:/tmp> rm /tmp/exercise.txt

  </pre>
</p><hr>



<p>
  <pre>
    <h2>Standard File Streams </h2>
    When commands are executed, by default there are three standard file streams (or descriptors) always open for use: 
    standard input (standard in or stdin), standard output (standard out or stdout) and standard error (or stderr).

    Name 	          Symbolic Name 	    Value 	    Example
standard            input 	stdin 	    0 	        keyboard
standard output 	  stdout 	            1 	        terminal
standard error 	    stderr 	            2 	        log file


Usually, stdin is your keyboard, and stdout and stderr are printed on your terminal. stderr is often redirected to an error logging file, 
while stdin is supplied by directing input to come from a file or from the output of a previous command through a pipe. stdout is also often redirected into a file. 
Since stderr is where error messages are written, usually nothing will go there.

In Linux, all open files are represented internally by what are called file descriptors. 
Simply put, these are represented by numbers starting at zero. stdin is file descriptor 0, stdout is file descriptor 1, and stderr is file descriptor 2. 
Typically, if other files are opened in addition to these three, which are opened by default, they will start at file descriptor 3 and increase from there.

On the next page and in the chapters ahead, you will see examples which alter where a running command gets its input,
where it writes its output, or where it prints diagnostic (error) messages. 
  </pre>
</p><hr>



<p>
  <pre>
    <h2>I/O Redirection</h2>
      

Through the command shell, we can redirect the three standard file streams so that we can get input from either a file or another command, 
instead of from our keyboard, and we can write output and errors to files or use them to provide input for subsequent commands.

For example, if we have a program called do_something that reads from stdin and writes to stdout and stderr, 
we can change its input source by using the less-than sign (<) followed by the name of the file to be consumed for input data:

$ do_something < input-file

If you want to send the output to a file, use the greater-than sign (>) as in:

$ do_something > output-file

Because stderr is not the same as stdout, error messages will still be seen on the terminal windows in the above example.

If you want to redirect stderr to a separate file, you use stderr’s file descriptor number (2), the greater-than sign (>), 
followed by the name of the file you want to hold everything the running command writes to stderr:

$ do_something 2> error-file

NOTE: By the same logic, do_something 1> output-file is the same as do_something > output-file.

A special shorthand notation can send anything written to file descriptor 2 (stderr) to the same place as file descriptor 1 (stdout): 2>&1.

$ do_something > all-output-file 2>&1

bash permits an easier syntax for the above:

$ do_something >& all-output-file

  </pre>
</p><hr>



<p>
  <pre>
    <h2>Pipes</h2>
    The UNIX/Linux philosophy is to have many simple and short programs (or commands) cooperate together to produce quite complex results, 
    rather than have one complex program with many possible options and modes of operation. In order to accomplish this, extensive use of pipes is made. 
    You can pipe the output of one command or program into another as its input.

In order to do this, we use the vertical-bar, pipe symbol (|), between commands as in:

$ command1 | command2 | command3

The above represents what we often call a pipeline, and allows Linux to combine the actions of several commands into one. 
This is extraordinarily efficient because command2 and command3 do not have to wait for the previous pipeline commands to complete before they can begin hacking at the data in their input streams; 
on multiple CPU or core systems, the available computing power is much better utilized and things get done quicker.

Furthermore, there is no need to save output in (temporary) files between the stages in the pipeline, 
which saves disk space and reduces reading and writing from disk, which is often the slowest bottleneck in getting something done.
  
<img src="images/pipeline.png">
</pre>
</p><hr>



<p>
  <pre>
    <h2>Searching for Files</h2>
    The main tools for doing this are the locate and find utilities. 
    We will also show how to use wildcards in bash, in order to specify any file which matches a given generalized request.

    The locate utility program performs a search taking advantage of a previously constructed database of files and directories on your system, 
    matching all entries that contain a specified character string. This can sometimes result in a very long list.

To get a shorter (and possibly more relevant) list, we can use the grep program as a filter. grep will print only the lines that contain one or more specified strings, as in: 

$ locate zip | grep bin

which will list all the files and directories with both zip and bin in their name. We will cover grep in much more detail later. 
Notice the use of | to pipe the two commands together.

locate utilizes a database created by a related utility, updatedb. Most Linux systems run this automatically once a day. 
However, you can update it at any time by just running updatedb from the command line as the root user.

<img src="images/locatesuse.png">


<video width="1000" controls><source src="images/d9de7136-78d9-4cf5-9549-1b61e2f31d4e-mp4_720p.mp4"></video> </pre>

<ol>
  <li>Find all files with the extension .doc.</li>
  <li>Copy the file named pdb.doc from /usr/lib/python2.7 to the current working directory as Myfile.doc.</li>
  <li>Update the database used by locate by running updatedb.</li>
  <li>Locate the file Myfile.doc. (Remember that filenames are case sensitive!).</li>
</ol>

<ol>
  <li></li>
  student:/tmp> locate .doc
  /usr/lib/python2.7/pdb.doc
  <li></li>
  student:/tmp> 
  cp /usr/lib/python2.7/pdb.doc Myfile.doc
  <li></li>
  student:/tmp> sudo updatedb
  <li></li>
  student:/tmp> locate Myfile.doc
</ol>
</p>



<p>
  <pre>
    <h2>Wildcards and Matching File Names</h2>

    Wildcard 	        Result
?  	                  Matches any single character
* 	                  Matches any string of characters
[set] 	              Matches any character in the set of characters, for example [adf] will match any occurrence of a, d, or f
[!set] 	              Matches any character not in the set of characters


To search for files using the ? wildcard, replace each unknown character with ?. 
For example, if you know only the first two letters are 'ba' of a three-letter filename with an extension of .out, type ls ba?.out.

To search for files using the * wildcard, replace the unknown string with *. 
For example, if you remember only that the extension was .out, type ls *.out.


<video width="1000" controls><source src="images/162ffd59-cf5b-4896-aade-b99a16aa95fa-mp4_720p.mp4"></video>




<ol>
  <li>View all the files in the current directory using ls command with -a option.</li>
  <li>List (using ls) files with names starting with g and containing five letters.</li>
  <li>List (using ls) files whose names begin with mk and end with any characters.</li>
  <li>List (using ls) files having five letter names starting with g and second character between a-n.</li>
  <li>List (using ls) five letter named files starting with g and not having the second character between a-m.</li>
</ol>

<ol>
  <li></li>
  student:/tmp/play> ls -a
  .	gindxbib	mkfontscale
  ..	gio-querymodules-64	mkhybrid
  [	glib-compile-schemas	mkisofs
  a2p	glookbib	mkmanifest
  ab	glxgears	mkrfc2734
  abrt-action-analyze-backtrace	glxinfo	mkxauth
  abrt-action-analyze-c	gmake	mlabel
  abrt-action-analyze-ccpp-local	gneqn	mmc-tool
  <li></li>
  student:/tmp/play> ls g????
  gmake gneqn 
  <li></li>
  student:/tmp/play> ls mk*
  mkfontscale	mkhybrid	mkisofs	mkmanifest	mkrfc2734	mkxauth
  <li></li>
  student:/tmp/play> ls g[a-n]???
  gmake gneq
  <li></li>student:/tmp/play> ls g[!a-m]???
  gneq
</ol>
  </pre>
</p><hr>


<p>
  <pre>
    <h2>The find Program</h2>
    find is an extremely useful and often-used utility program in the daily life of a Linux system administrator. 
    It recurses down the filesystem tree from any particular directory (or set of directories) and locates files that match specified conditions. 
    The default pathname is always the present working directory.

For example, 
administrators sometimes scan for potentially large core files (which contain diagnostic information after a program fails) that are more than several weeks old in order to remove them.

It is also common to remove files in inessential or outdated files in /tmp (and other volatile directories, 
such as those containing cached files) that have not been accessed recently. 
Many Linux distributions use shell scripts that run periodically (through cron usually) to perform such house cleaning.

<img src="images/findubuntu.png">
  </pre>
</p><hr>



<p>
  <pre>
    <h2></h2>
  </pre>
</p>



<p>
  <pre>
    <h2>Using find</h2>

    When no arguments are given, find lists all files in the current directory and all of its subdirectories. 
    Commonly used options to shorten the list include -name (only list files with a certain pattern in their name),
     -iname (also ignore the case of file names), and -type (which will restrict the results to files of a certain specified type, 
     such as d for directory, l for symbolic link, or f for a regular file, etc.). 

    Searching for files and directories named gcc:
    
    <em>$ find /usr -name gcc</em>
    
    Searching only for directories named gcc:
    
    <em>$ find /usr -type d -name gcc</em>
    
    Searching only for regular files named gcc:
    
    <em>$ find /usr -type f -name gcc</em>

    <img src="images/findrhel7.png">
  </pre>
</p><hr>



<p>
  <pre>
    <h2>Using Advanced find Options</h2>
    Another good use of find is being able to run commands on the files that match your search criteria. The -exec option is used for this purpose.

To find and remove all files that end with .swp:

<em>$ find -name "*.swp" -exec rm {} ’;’</em>

The {} (squiggly brackets) is a placeholder that will be filled with all the file names that result from the find expression, 
and the preceding command will be run on each one individually.

Please note that you have to end the command with either ‘;’ (including the single-quotes) or "\;". Both forms are fine.

One can also use the -ok option, which behaves the same as -exec, except that find will prompt you for permission before executing the command. 
This makes it a good way to test your results before blindly executing any potentially dangerous commands.

<img src="images/LFS01_ch06_screen41.jpg">
  </pre>
</p><hr>



<p>
  <pre>
    <h2>Finding Files Based on Time and Size</h2>
    It is sometimes the case that you wish to find files according to attributes, 
    such as when they were created, last used, etc., or based on their size. It is easy to perform such searches.

To find files based on time:

<em>$ find / -ctime 3</em>

Here, -ctime is when the inode metadata (i.e. file ownership, permissions, etc.) last changed; it is often, but not necessarily, when the file was first created. 
You can also search for accessed/last read (-atime) or modified/last written (-mtime) times. 
The number is the number of days and can be expressed as either a number (n) that means exactly that value, +n, 
which means greater than that number, or -n, which means less than that number. There are similar options for times in minutes (as in -cmin, -amin, and -mmin).

To find files based on sizes:

<em>$ find / -size 0</em>

Note the size here is in 512-byte blocks, by default; you can also specify bytes (c), kilobytes (k), megabytes (M), gigabytes (G), etc. As with the time numbers above, 
file sizes can also be exact numbers (n), +n or -n. For details, consult the man page for find.

For example, to find files greater than 10 MB in size and running a command on those files:

<em>$ find / -size +10M -exec command {} ’;’</em>

<img src="images/findrhel7.png"><br>



<video width="1000" controls><source src="images/467b3768-bf4b-4ba1-9899-87ef71310722-mp4_720p.mp4"></video>
  </pre>
</p><hr>



<p>
  <pre>
    <h2>Finding Directories and Creating Symbolic Links</h2>


Find the init.d directory, starting from /, and then create a symbolic link from within your home directory to this directory.

Note that this SysVinit directory is no longer used much in systemd-based systems, but is kept for backwards compatibility reasons.

Check out the solution provided on the next page.




<em>student:/tmp> find / -type d -name init.d
student:/tmp> cd ~
student:/home/student> ln -s /etc/init.d .  </em>

Note you will get a lot of noise about trying to look at files and directories normal users are not allowed to examine. If you preface the find command with sudo these will not occur.

  </pre>
</p><hr>



<p>
  <pre>
    <h2>Package Management Systems on Linux</h2>
    The core parts of a Linux distribution and most of its add-on software are installed via the Package Management System. 
    Each package contains the files and other instructions needed to make one software component work well and cooperate with the other components that comprise the entire system. 
    Packages can depend on each other. For example, a package for a web-based application written in PHP can depend on the PHP package.
    There are two broad families of package managers: those based on Debian and those which use RPM as their low-level package manager. 
    The two systems are incompatible, but broadly speaking, provide the same features and satisfy the same needs. 
    There are some other systems used by more specialized Linux distributions.

In this section, you will learn how to install, remove, or search for packages from the command line using these two package management systems.
  </pre>
</p><hr>

<p>
  <pre>
    <h2>Package Managers: Two Levels</h2>
    Both package management systems operate on two distinct levels: a low-level tool (such as dpkg or rpm) takes care of the details of unpacking individual packages,
    running scripts, getting the software installed correctly, while a high-level tool (such as apt-get, dnf, yum, or zypper) works with groups of packages, 
    downloads packages from the vendor, and figures out dependencies.

Most of the time users need to work only with the high-level tool, which will take care of calling the low-level tool as needed. 
Dependency resolution is a particularly important feature of the high-level tool, as it handles the details of finding and installing each dependency for you. 
Be careful, however, as installing a single package could result in many dozens or even hundreds of dependent packages being installed.
<img src="images/package_managers.png">
  </pre>
</p><hr>



<p>
  <pre>
    <h2>Working With Different Package Management Systems</h2>
    The Advanced Packaging Tool (apt) is the underlying package management system that manages software on Debian-based systems. 
    While it forms the backend for graphical package managers, such as the Ubuntu Software Center and synaptic, its native user interface is at the command line, 
    with programs that include apt (or apt-get) and apt-cache.

dnf is the open source command-line package-management utility for the RPM-compatible Linux systems that belongs to the Red Hat family. dnf has both command line and graphical user interfaces. 
Fedora and RHEL 8 replaced the older yum utility with dnf, thereby eliminating a lot of historical baggage, 
as well as introducing many nice new capabilities. dnf is pretty much backwards-compatible with yum for day-to-day commands.
<img src="images/Installing-Software-Chapter-7-Command-Line-Operations-Introduction-to-Linux-edX.png">
  </pre>
</p>



<p>
  <pre>
    <h2>Low-Level Debian Package Management with dpkg</h2>
    <video width="1000" controls><source src="images/LINILXXX2017-V001500_DTH.mp4"></video>
  </pre>
</p><hr>



<p>
  <pre>
    <h2>Low-Level RPM Package Management with rpm</h2>
    <video width="1000" controls><source src="images/LINILXXX2017-V001600_DTH.mp4"></video>
  </pre>
</p><hr>



<p>
  <pre>
    <h2>High-Level Package Management with dnf</h2>
    <video width="1000" controls><source src="images/825ce6b8-4cc5-4680-ae8d-a31efd12b83a-mp4_720p.mp4"></video>
  </pre>
</p><hr>



<p>
  <pre>
    <h2>High-Level Package Management with zypper on openSUSE</h2>
    <video width="1000" controls><source src="images/LINILXXX2017-V002400_DTH.mp4"></video>
  </pre>
</p><hr>



<p>
  <pre>
    <h2>High-Level Package Management with apt on Ubuntu</h2>
    <video width="1000" controls><source src="images/LINILXXX2017-V001800_DTH.mp4"></video>
  </pre>
</p><hr>



<p>
  <pre>
    <h2>Installing and Removing Software Packages</h2>


<em>student:/tmp> apt-get install dump
student:/tmp> apt-get remove dump      



student:/tmp> dnf install dump
student:/tmp> dnf remove dump      



student:/tmp> yum install dump
student:/tmp> yum remove dump      



student:/tmp> zypper install dump
student:/tmp> zypper remove dump
</em>
  </pre>
</p><hr>

<p><h3 style="color: rgb(12,178,18);">Chapter 8</h3></p>
<p>
  <pre>
    <h2>Linux Documentation</h2>

<img src="images/LFS01_ch07_screen03.jpg">



    Important Linux documentation sources include:

            The man pages (short for manual pages)
            GNU Info
            The help command and --help option
            Other documentation sources, e.g. <a href="https://www.gentoo.org/support/documentation/" target="_blank">Gentoo Handbook</a> or <a href="https://help.ubuntu.com/community/CommunityHelpWiki" target="_blank"> Ubuntu Documentation.</a>
  </pre>
</p><hr>



<p>
  <pre>
    <h2>The man pages</h2>
    The man pages are the most often-used source of Linux documentation. 
    They provide in-depth documentation about many programs and utilities, as well as other topics, including configuration files, and programming APIs for system calls, library routines, and the kernel. 
    They are present on all Linux distributions and are always at your fingertips.

The man pages infrastructure was first introduced in the early UNIX versions, at the beginning of the 1970s. 
The name man is just an abbreviation for manual.

Typing man with a topic name as an argument retrieves the information stored in the topic's man pages.

man pages are often converted to other formats, such as PDF documents and web pages. 
To learn more, take a look at <a href="https://man7.org/linux/man-pages/" target="_blank">Linux man pages online. </a>
Many web pages have a graphical interface for help items, which may include man pages.

Other sources of documentation include published books and many Internet sites.
  </pre>
</p><hr>



<p>
  <pre>
    <h2>man</h2>
    The man program searches, formats, and displays the information contained in the man page system. 
    Because many topics have copious amounts of relevant information, output is piped through a pager program (such as less) to be viewed one page at a time. 
    At the same time, the information is formatted for a good visual display.

A given topic may have multiple pages associated with it and there is a default order determining which one is displayed when no options or section number is specified. 
To list all pages on the topic, use the -f option. To list all pages that discuss a specific topic (even if the specified subject is not present in the name), use the –k option.

            <em>man –f</em> generates the same result as typing <em>whatis</em>.
            <em>man –k</em> generates the same result as typing <em>apropos</em>.

The default order is specified in <i>/etc/man_db.conf</i> and is roughly (but not exactly) in ascending numerical order by section.


<img src="images/man1.png">
  </pre>
</p>



<p>
  <pre>
    <h2>manual Chapters</h2>
    The man pages are divided into chapters numbered 1 through 9. In some cases, a letter is appended to the chapter number to identify a specific topic. 
    For example, many pages describing part of the X Window API are in chapter 3X.

  The chapter number can be used to force man to display the page from a particular chapter. 
  It is common to have multiple pages across multiple chapters with the same name, especially for names of library functions or system calls.

  With the -a parameter, man will display all pages with the given name in all chapters, one after the other, as in:

  <em>$ man -a socket</em>

  <img src="images/manchap.png">
  </pre>
</p><hr>



<p>
  <pre>
    <h2>Using man</h2>
    <video width="1000" controls><source src="images/LINILXXX2017-V002300_DTH.mp4"></video>
  </pre>
</p><hr>



<p>
  <pre>
    <h2>Working with man</h2>
    <ol>
      <li>Finding man pages
        From the command line, bring up the man page for man itself. Scroll down to the EXAMPLES section.</li>
      <li>Finding man pages by topic
        What man pages are available that document file compression?</li>
      <li>Finding man pages by section
        From the command line, bring up the man page for the printf library function. 
        In which manual page section are library functions found?</li>
    </ol>

    <ol>
      <li><em>student:/tmp> man man</em>
        Use the Page Down key or search in less with the '/' key for the EXAMPLES section.</li>
      <li><em>student:/tmp> man -k compress</em>
        or
        <em>student:/tmp> apropos compress</em>
        will bring up a long list of programs and references, 
        including gzip, bzip2 and xz, and a number of file utilities that work with compressed files, 
        such as zless, zgrep, bzcat, and xzdiff.</li>
      <li><em>student:/tmp> man 3 printf</em>
        (man printf will bring up the command-line utility (section 1) of the same name.)</li>
    </ol>
  </pre>
</p><hr>



<p>
  <pre>
    <h2>The GNU Info System</h2>
    The next source of Linux documentation is the GNU Info System.

This is the GNU project's standard documentation format, which it prefers as an alternative to man. 
The Info System is basically free-form, and supports linked subsections.

Functionally, info resembles man in many ways. However, topics are connected using links (even though its design predates the World Wide Web). 
Information can be viewed through either a command line interface, a graphical help utility, printed or viewed online.
  </pre>
</p><hr>



<p>
  <pre>
    <h2>Using info from the Command Line</h2>
    Typing info with no arguments in a terminal window displays an index of available topics. You can browse through the topic list using the regular movement keys: arrows, Page Up, and Page Down.

You can view help for a particular topic by typing info  	&lt;topic name&gt;. The  system then searches for the topic in all available info files.

Some useful keys are: q to quit, h for help, and Enter to select a menu item.

<img src="images/infoubuntu.png">
  </pre>
</p><hr>



<p>
  <pre>
    <h2>info Page Structure</h2>
    The topic which you view in an info page is called a node. The table lists the basic keystrokes for moving between nodes.

Nodes are essentially sections and subsections in the documentation. You can move between nodes or view each node sequentially. 
Each node may contain menus and linked subtopics, or items.

Items function like browser links and are identified by an asterisk (*) at the beginning of the item name. 
Named items (outside a menu) are identified with double-colons (::) at the end of the item name. 
Items can refer to other nodes within the file or to other files. 

Key  	Function
n 	  Go to the next node
p 	  Go to the previous node
u 	  Move one node up in the index
  </pre>
</p><hr>



<p>
  <pre>
    <h2>Using info</h2>
    <video width="1000" controls><source src="images/LINILXXX2017-V002200_DTH.mp4"></video>
  </pre>
</p><hr>



<p>
  <pre>
    <h2>Working with info</h2>
    From the command line, bring up the info page for cpio. Bring up the tutorial.



<em>student:/tmp> info cpio</em>

Move the cursor down to the Tutorial node, and press Enter.

  </pre>
</p><hr>



<p>
  <pre>
    <h2>The --help Option</h2>
    Another important source of Linux documentation is use of the --help option.

Most commands have an available short description which can be viewed using the --help or the -h option along with the command or application. 
For example, to learn more about the man command, you can type: 

<em>$ man --help</em>

The --help option is useful as a quick reference and it displays information faster than the man or info pages.

<img src="images/manhelp.png">

  </pre>
</p><hr>



<p>
  <pre>
    <h2>The help Command</h2>
    When run within a bash command shell, some popular commands (such as echo and cd) actually run especially built-in bash versions
    of the commands rather than the usual binaries found on the file system, say under <i>/bin or /usr/bin</i>. 
    It is more efficient to do so as execution is faster because fewer resources are used (we will discuss command shells later). 
    One should note that there can be some (usually small) differences in the two versions of the command.

To view a synopsis of these built-in commands, you can simply type help as shown in the screenshot.

For these built-in commands, help performs the same basic function as the -h and --help arguments perform for standalone programs.


<img src="images/helpbash.png">

  </pre>
</p><hr>



<p>
  <pre>
    <h2> Working with Command Line help</h2>

    List the available options for the mkdir command, in more than one way.

<em>student:/tmp> mkdir --help </em>
<em>student:/tmp>$ man mkdir</em>

  </pre>
</p><hr>



<p>
  <pre>
    <h2>Other Documentation Sources</h2>
    In addition to the man pages, the GNU Info System, and the help command, there are other sources of Linux documentation, 
    some examples of which include:
    <ul>
      <li>Desktop help system</li>
      <li>Package documentation</li>
      <li>Online resources.</li>
    </ul>

    <img src="images/LFS01_ch07_screen23.jpg">
  </pre>
</p><hr>



<p>
  <pre>
    <h2>Graphical Help Systems</h2>
    All Linux desktop systems have a graphical help application. 
    This application is usually displayed as a question-mark icon or an image of a ship’s life-preserver, and can also always be found within the menu system. 
    These programs usually contain custom help for the desktop itself and some of its applications, and will sometimes also include graphically-rendered info and man pages.

If you do not want to spend time hunting for the right icon or menu item to launch the help application, 
you can also start the graphical help system from a terminal window or command prompt by using one of the following utility programs:

            GNOME: gnome-help or yelp
            KDE: khelpcenter
GNOME HELP
<img src="images/gnome-help.png">






KDE HELP
<img src="images/khelpcenter.png">
  </pre>
</p><hr>



<p>
  <pre>
    <h2>Package Documentation</h2>
    Linux documentation is also available as part of the package management system. 
    Usually, this documentation is directly pulled from the upstream source code, but it can also contain information about how the distribution packaged and set up the software.

Such information is placed under the <i>/usr/share/doc</i> directory, grouped in subdirectories named after each package, perhaps including the version number in the name.

<img src="images/usrsharedoc.png">
</pre>
</p><hr>



<p>
  <pre>
    <h2>Online Resources</h2>



There are many places to access online Linux documentation, and a little bit of searching will get you buried in it.

The following book has been well-reviewed by other users of this course. It is a free, 
downloadable command line compendium under a Creative Commons license: "The Linux Command Line" by William Shotts.

You can also find very helpful documentation for each distribution. 
Each distribution has its own user-generated forums and wiki sections. Here are just a few links to such sources:

            Ubuntu Documentation
            CentoS Documentation
            openSUSE Documentation
            Gentoo Documentation
            Fedora Documentation.

Moreover, you can use online search sites to locate helpful resources from all over the Internet, 
including blog posts, forum and mailing list posts, news articles, and so on.

  </pre>
</p><hr>



<p>
  <pre>
    <h2> Working with Graphical Help Systems</h2>
    Find the graphical help system on your desktop and try to locate within it the man pages for printf. This may be difficult, so do not waste too much time before looking at the suggestions below. 

If you have been unable to find the man pages this way, we cannot give a unique solution to this. It varies from one Linux distribution to another, 
and one version to the next, but you should be able to hunt and find out where this is located and get familiar with the interface.

In earlier Linux distributions this was a rather easy task. Those days are gone for some desktops today.

If you are having trouble finding this on recent GNOME desktops, you are not alone. For some reason, clicking on Documentation > Help only brings up documentation about GNOME itself, using the yelp browser.

However, if at the command line you type something like:
<em>student:/tmp> yelp man:cat</em>
it will indeed bring up the man page for cat. However, you cannot type something like man:ls in the location bar and have it work, 
unless you hit CTRL-l first! It is not exactly clear whether this is a bug or a feature, but a bug seems more likely. Once you are in the page, clicking on links to get other man pages works just fine.

The same mechanism works to get info pages as well, as in:

<em>student:/tmp> yelp info:cpio</em>
  </pre>
</p><hr>

<h3 style="color: rgb(12,178,18);">Chapter 9 Process</h3>

<p>
  <pre>
    <h2>What Is a Process?</h2>
    A process is simply an instance of one or more related tasks (threads) executing on your computer. 
    It is not the same as a program or a command. A single command may actually start several processes simultaneously. Some processes are independent of each other and others are related. 
    A failure of one process may or may not affect the others running on the system.


    <img src="images/LFS01_ch16_screen03.jpg">

    Processes use many system resources, such as memory, CPU (central processing unit) cycles, and peripheral devices, such as network cards, hard drives, printers and displays. 
    The operating system (especially the kernel) is responsible for allocating a proper share of these resources to each process and ensuring overall optimized system utilization.
  </pre>
</p><hr>



<p>
  <pre>
    <h2>Process Types</h2>
    A terminal window (one kind of command shell) is a process that runs as long as needed. 
    It allows users to execute programs and access resources in an interactive environment. You can also run programs in the background, which means they become detached from the shell.

Processes can be of different types according to the task being performed. Here are some different process types, along with their descriptions and examples:

process type                                description                                                                                                         example

Interactively               Need to be started by a user, either at a command line or through a                                                             bash, firefox, top
process                            graphical interface such as an icon or a menu selection.              


batch                       Automatic processes which are scheduled from and then disconnected from the terminal.                                           updatedb, ldconfig
                                These tasks are queued and work on a FIFO (First-In, First-Out) basis.
processes


daemons                         Server processes that run continuously.                                                                                     httpd, sshd, libvirtd
                                Many are launched during system startup and then wait for a user or system 
                                request indicating that their service is required.

threads                         Lightweight processes. These are tasks that run under the umbrella of a main process,                                       firefox, gnome-terminal-server
                                sharing memory and other resources, but are scheduled and run by the system 
                                on an individual basis. 
                                An individual thread can end without terminating the whole process and a process 
                                can create new threads at any time. 
                                Many non-trivial programs are multi-threaded.


kernel                          Kernel tasks that users neither start nor terminate and have little control over.                                           kthreadd, migration, ksoftirqd
                                These may perform actions like moving a thread from one CPU to another, or making sure 
                                input/output operations to disk are completed.
threads
</pre>
</p><hr>



<p>
  <pre>
    <h2>Process Scheduling and States</h2>

    A critical kernel function called the scheduler constantly shifts processes on and off the CPU, sharing time according to relative priority, 
    how much time is needed and how much has already been granted to a task.

When a process is in a so-called running state, it means it is either currently executing instructions on a CPU, or is waiting to be granted a share of time (a time slice) so it can execute. 
All processes in this state reside on what is called a run queue and on a computer with multiple CPUs, or cores, there is a run queue on each.
  
<img src="images/LFS01_ch16_screen05.jpg">

However, sometimes processes go into what is called a sleep state, generally when they are waiting for something to happen before they can resume, perhaps for the user to type something. 
In this condition, a process is said to be sitting in a wait queue.

There are some other less frequent process states, especially when a process is terminating. Sometimes, a child process completes, but its parent process has not asked about its state. 
Amusingly, such a process is said to be in a zombie state; it is not really alive, but still shows up in the system's list of processes.
</pre>
</p><hr>



<p>
  <pre>
    <h2>Process and Thread IDs</h2>
    At any given time, there are always multiple processes being executed. The operating system keeps track of them by assigning each a unique process ID (PID) number. 
    The PID is used to track process state, CPU usage, memory use, precisely where resources are located in memory, and other characteristics.

New PIDs are usually assigned in ascending order as processes are born. Thus, PID 1 denotes the init process (initialization process), and succeeding processes are gradually assigned higher numbers.

The table explains the PID types and their descriptions:

ID Type 	                        Description
Process ID (PID) 	                Unique Process ID number
Parent Process ID (PPID) 	        Process (Parent) that started this process. If the parent dies, the PPID will refer to an adoptive parent; on recent kernels, this is kthreadd which has PPID=2.
Thread ID (TID) 	                Thread ID number. This is the same as the PID for single-threaded processes. For a multi-threaded process, each thread shares the same PID, but has a unique TID.
  </pre>
</p><hr>



<p>
  <pre>
    <h2>Terminating a Process</h2>
    At some point, one of your applications may stop working properly. How do you eliminate it?

To terminate a process, you can type kill -SIGKILL <pid> or kill -9 <pid>.

Note, however, you can only kill your own processes; those belonging to another user are off limits, unless you are root.

<img src="images/rhelkill.png">
  </pre>
</p><hr>



<p>
  <pre>
    <h2>User and Group IDs</h2>


Many users can access a system simultaneously, and each user can run multiple processes. 
The operating system identifies the user who starts the process by the Real User ID (RUID) assigned to the user.

The user who determines the access rights for the users is identified by the Effective UID (EUID). The EUID may or may not be the same as the RUID.

Users can be categorized into various groups. Each group is identified by the Real Group ID (RGID). 
The access rights of the group are determined by the Effective Group ID (EGID). Each user can be a member of one or more groups.

Most of the time we ignore these details and just talk about the User ID (UID) and Group ID (GID).

  </pre>
</p><hr>



<p>
  <pre>
    <h2>More About Priorities</h2>

    At any given time, many processes are running (i.e. in the run queue) on the system. However, a CPU can actually accommodate only one task at a time, 
    just like a car can have only one driver at a time. Some processes are more important than others, so Linux allows you to set and manipulate process priority. 
    Higher priority processes get preferential access to the CPU.

The priority for a process can be set by specifying a nice value, or niceness, for the process. The lower the nice value, the higher the priority. 
Low values are assigned to important processes, while high values are assigned to processes that can wait longer. A process with a high nice value simply allows other processes to be executed first.
In Linux, a nice value of -20 represents the highest priority and +19 represents the lowest. While this may sound backwards, this convention (the nicer the process, the lower the priority) goes back to the earliest days of UNIX.

<img src="images/niceout.png">

You can also assign a so-called real-time priority to time-sensitive tasks, such as controlling machines through a computer or collecting incoming data. 
This is just a very high priority and is not to be confused with what is called hard real-time which is conceptually different, and has more to do with making sure a job gets completed within a very well-defined time window.
  
<img src="images/LFS01_ch16_screen08.jpg">

<video width="1000" controls><source src="images/LinuxFoundationXLFS101x-V000100_DTH.mp4"></video>
</pre>
</p><hr>



<p>
  <pre>
    <h2>Load Averages</h2>
    The load average is the average of the load number for a given period of time. It takes into account processes that are:

            Actively running on a CPU.
            Considered runnable, but waiting for a CPU to become available.
            Sleeping: i.e. waiting for some kind of resource (typically, I/O) to become available.

NOTE: Linux differs from other UNIX-like operating systems in that it includes the sleeping processes. 
Furthermore, it only includes so-called uninterruptible sleepers, those which cannot be awakened easily.

The load average can be viewed by running w, top or uptime. We will explain the numbers on the next page.
<img src="images/wuptimesuse.png">
  </pre>
</p><hr>



<p>
  <pre>
    <h2>Interpreting Load Averages</h2>
    The load average is displayed using three numbers (0.45, 0.17, and 0.12) in the below screenshot. Assuming our system is a single-CPU system, the three load average numbers are interpreted as follows:

            0.45: For the last minute the system has been 45% utilized on average.
            0.17: For the last 5 minutes utilization has been 17%.
            0.12: For the last 15 minutes utilization has been 12%.

If we saw a value of 1.00 in the second position, that would imply that the single-CPU system was 100% utilized, on average, over the past 5 minutes; this is good if we want to fully use a system. 
A value over 1.00 for a single-CPU system implies that the system was over-utilized: there were more processes needing CPU than CPU was available.

If we had more than one CPU, say a quad-CPU system, we would divide the load average numbers by the number of CPUs. 
In this case, for example, seeing a 1 minute load average of 4.00 implies that the system as a whole was 100% (4.00/4) utilized during the last minute.

Short-term increases are usually not a problem. A high peak you see is likely a burst of activity, not a new level. 
For example, at start up, many processes start and then activity settles down. If a high peak is seen in the 5 and 15 minute load averages, it may be cause for concern.
  
<img src="images/woutputrhel.png">
</pre>
</p><hr>



<p>
  <pre>
    <h2>Background and Foreground Processes</h2>
    Linux supports background and foreground job processing. A job in this context is just a command launched from a terminal window. 
    Foreground jobs run directly from the shell, and when one foreground job is running, other jobs need to wait for shell access (at least in that terminal window if using the GUI) until it is completed. 
    This is fine when jobs complete quickly. But this can have an adverse effect if the current job is going to take a long time (even several hours) to complete.

In such cases, you can run the job in the background and free the shell for other tasks. The background job will be executed at lower priority, which, in turn, 
will allow smooth execution of the interactive tasks, and you can type other commands in the terminal window while the background job is running. By default, all jobs are executed in the foreground. 
You can put a job in the background by suffixing & to the command, for example: updatedb &.

You can either use CTRL-Z to suspend a foreground job or CTRL-C to terminate a foreground job and can always use the bg and fg commands to run a process in the background and foreground, respectively.

<img src="images/bgfgrhel.png">
</pre>
</p><hr>



<p>
  <pre>
    <h2>Managing Jobs</h2>
    The jobs utility displays all jobs running in background. The display shows the job ID, state, and command name, as shown here.

jobs -l provides the same information as jobs, and adds the PID of the background jobs.

The background jobs are connected to the terminal window, so, if you log off, 
the jobs utility will not show the ones started from that window.

<img src="images/jobsrhel.png">
  </pre>
</p><hr>



<p>
  <pre>
    <h2>Getting Uptime and Load Averages</h2>



Ascertain how long your system has been up. 

Display its load averages.




A very simple method is just to use the uptime utility:

<em>student:/tmp> uptime</em>

<i>10:26:40 up  3:19,  5 users,  load average: 1.46, 1.40, 1.19</i>

A second method is to look at the first line of output from top (to be discussed in detail shortly):

<em>student:/tmp> top | head</em>

<i>top - 10:28:11 up  3:20,  5 users,  load average: 1.93, 1.52, 1.25
Tasks: 313 total,   1 running, 312 sleeping,   0 stopped,   0 zombie
%Cpu(s):  1.0 us,  0.3 sy,  0.0 ni, 98.2 id,  0.5 wa,  0.0 hi,  0.0 si,  0.0
KiB Mem : 16284472 total,  6556792 free,  1029760 used,  8697920 buff/cache
KiB Swap:  8290300 total,  8290300 free,        0 used. 10364220 avail Mem
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
2615 coop      20   0  504536 186312  65488 S   6.7  1.1   6:28.30 skype-b+
18248 coop      20   0  655804  50816  30884 S   6.7  0.3   0:20.11 emacs
    1 root      20   0  204912   6508   3956 S   0.0  0.0   0:00.92 systemd</i>

A third method is to use w:
<em>student:/tmp> w</em>

<i>10:30:51 up  3:23,  5 users,  load average: 0.55, 1.11, 1.14
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
coop     :0       :0               07:08   ?xdm?  16:51   0.19s gdm-session-
coop     pts/0    :0               07:09    2:22m  0.12s  0.12s bash
coop     pts/1    :0               07:09    1:37m  0.42s  0.42s bash
coop     pts/2    :0               07:09    0.00s 51.09s  0.00s w
coop     pts/3    :0               07:09   27:08   0.25s  0.25s bash</i>

  </pre>
</p><hr>



<p>
  <pre>
    <h2>Background and Foreground Jobs</h2>


We are going to launch a graphical program from a terminal window so that one can no longer type in the window. gedit is an easy choice, but you can substitute any other program that does this.

Open gedit on a new file as in:

<em>$ gedit somefile</em>     

While you can still type in the terminal window, the shell will not pay attention to what you input.
While your pointer is over the terminal window, hit CTRL-Z.

<em>^Z</em>
<i>[3]+  Stopped                 gedit somefile</i>

You can no longer type in the gedit window.
With jobs -l, see what processes have been launched from this terminal window:

<em>$ jobs -l</em>
<i>[1]  17705 Running                 evince *pdf &
[2]- 18248 Running                 emacs /tmp/hello.tex &
[3]+ 19827 Stopped                 gedit somefile</i>     
Now put the most recent job (gedit somefile) in the background:

<em>$ bg</em>
<i>[3]+ gedit somefile &</i>

Now you should be able to type in the gedit window.
Put the process in foreground again:

<em>$ fg</em>
<i>gedit somefile</i>

Note you once again input to the terminal window. It has no effect.
To clean up, suspend the process again and then use kill to terminate it:

<em>^Z</em>
<i>[3]+  Stopped                 gedit somefile</i>
<em>$ jobs -l</em> 
<i>[1]  17705 Running                 evince *pdf
[2]- 18248 Running                 emacs /tmp/hello.tex
[3]+ 19827 Stopped                 gedit somefile</i>
<em>$ kill -9 19827</em>
<em>$ jobs -l[wtf]</em>
[<i>1]  17705 Running                 evince *pdf &
[2]- 18248 Running                 emacs /tmp/hello.tex &
[3]+ 19827 Killed                  gedit somefile</i>
<em>$ jobs -l</em>
<i>[1]- 17705 Running                 evince *pdf &
[2]- 18248 Running                 emacs /tmp/hello.tex &</i>


  </pre>
</p><hr>



<p>
  <pre>
    <h2>The ps Command (System V Style)</h2>

    ps provides information about currently running processes keyed by PID. If you want a repetitive update of this status, 
    you can use top or other commonly installed variants (such as htop or atop) from the command line, or invoke your distribution's graphical system monitor application.

ps has many options for specifying exactly which tasks to examine, what information to display about them, and precisely what output format should be used.

Without options, ps will display all processes running under the current shell. You can use the -u option to display information of processes for a specified username. 
The command ps -ef displays all the processes in the system in full detail. The command ps -eLf goes one step further and displays one line of information for every thread (remember, a process can contain multiple threads).

<img src="images/ubuntupsef.png">
  </pre>
</p><hr>



<p>
  <pre>
    <h2>The ps Command (BSD Style)</h2>

    ps has another style of option specification, which stems from the BSD variety of UNIX, 
    where options are specified without preceding dashes. For example, the command ps aux displays all processes of all users. 
    The command ps axo allows you to specify which attributes you want to view.

    The screenshot shows a sample output of ps with the aux and axo qualifiers.  

    <img src="images/psbsdrhel.png">
  </pre>
</p><hr>



<p>
  <pre>
    <h2></h2>
  </pre>
</p>



<p>
  <pre>
    <h2>Using ps</h2>


    <video width="1000" controls><source src="images/322cee4c-fb31-4b26-98c0-0fcb3da2b7aa-mp4_720p.mp4"></video>
  </pre>
</p><hr>



<p>
  <pre>
    <h2>The Process Tree</h2>
    <b>pstree</b> displays the processes running on the system in the form of a tree diagram showing the relationship between a process and its parent process and any other processes that it created. 
    Repeated entries of a process are not displayed, and threads are displayed in curly braces.
  
  <img src="images/ubuntupstree.png">
  </pre>
</p><hr>



<p>
  <pre>
    <h2>top</h2>

    While a static view of what the system is doing is useful, monitoring the system performance live over time is also valuable. One option would be to run ps at regular intervals, say, every few seconds.
  A better alternative is to use top to get constant real-time updates (every two seconds by default), 
  until you exit by typing q.top clearly highlights which processes are consuming the most CPU cycles and memory (using appropriate commands from within top).

  <img src="images/toprhel.png">

</pre>
</p><hr>



<p>
  <pre>
    <h2>First Line of the top Output</h2>

    The first line of the top output displays a quick summary of what is happening in the system, including:

            How long the system has been up
            How many users are logged on
            What is the load average

The load average determines how busy the system is. A load average of 1.00 per CPU indicates a fully subscribed, but not overloaded, system. If the load average goes above this value, 
it indicates that processes are competing for CPU time. If the load average is very high, it might indicate that the system is having a problem, such as a runaway process (a process in a non-responding state).

<img src="images/toprhelline1.png">
</pre>
</p><hr>



<p>
  <pre>
    <h2>Second Line of the top Output</h2>

    The second line of the top output displays the total number of processes, the number of running, sleeping, stopped, and zombie processes. 
    Comparing the number of running processes with the load average helps determine if the system has reached its capacity or perhaps a particular user is running too many processes. 
    The stopped processes should be examined to see if everything is running correctly.
  
    <img src="images/toprhelline2.png">
  </pre>
</p><hr>



<p>
  <pre>
    <h2>Third Line of the top Output</h2>

    The third line of the top output indicates how the CPU time is being divided between the users (us) and the kernel (sy) by displaying the percentage of CPU time used for each.

The percentage of user jobs running at a lower priority (niceness - ni) is then listed. Idle mode (id) should be low if the load average is high, and vice versa. 
The percentage of jobs waiting (wa) for I/O is listed. Interrupts include the percentage of hardware (hi) vs. software interrupts (si). 
Steal time (st) is generally used with virtual machines, which has some of its idle CPU time taken for other uses.
  
<img src="images/toprhelline3.png">
</pre>
</p><hr>



<p>
  <pre>
    <h2>Fourth and Fifth Lines of the top Output</h2>

    The fourth and fifth lines of the top output indicate memory usage, which is divided in two categories:

            Physical memory (RAM) – displayed on line 4.
            Swap space – displayed on line 5.

Both categories display total memory, used memory, and free space.

You need to monitor memory usage very carefully to ensure good system performance. Once the physical memory is exhausted, 
the system starts using swap space (temporary storage space on the hard drive) as an extended memory pool, and since accessing disk is much slower than accessing memory, 
this will negatively affect system performance.

If the system starts using swap often, you can add more swap space. However, adding more physical memory should also be considered.
  
<img src="images/toprhelline4-5.png">
</pre>
</p><hr>



<p>
  <pre>
    <h2>Process List of the top Output</h2>

    Each line in the process list of the top output displays information about a process. By default, processes are ordered by highest CPU usage. The following information about each process is displayed:

            Process Identification Number (PID)
            Process owner (USER)
            Priority (PR) and nice values (NI)
            Virtual (VIRT), physical (RES), and shared memory (SHR)
            Status (S)
            Percentage of CPU (%CPU) and memory (%MEM) used
            Execution time (TIME+)
            Command (COMMAND).
<img src="images/toprhelOUT.png">
  </pre>
</p><hr>


<p>
  <pre>
    <h2>Interactive Keys with top</h2>

    Besides reporting information, top can be utilized interactively for monitoring and controlling processes. 
    While top is running in a terminal window, you can enter single-letter commands to change its behavior. 
    For example, you can view the top-ranked processes based on CPU or memory usage. 
    If needed, you can alter the priorities of running processes or you can stop/kill a process.

The table lists what happens when pressing various keys when running top:
<img src="images/Listing-Processes-ps-and-top-Chapter-9-Processes-Introduction-to-Linux-edX.png">
  </pre>
</p><hr>


<p>
  <pre>
    <h2>Using top</h2>
    <video width="1000" controls><source src="images/da3272c6-9559-41ac-a8b2-1168df22670c-mp4_720p.mp4"></video>
  </pre>
</p><hr>


<p>
  <pre>
    <h2>Using System Monitoring</h2>

    <video width="1000" controls><source src="images/LinuxFoundationXLFS101x-V000200_DTH.mp4"></video>
  </pre>
</p><hr>


<p>
  <pre>
    <h2>Scheduling Future Processes Using at</h2>
    Suppose you need to perform a task on a specific day sometime in the future. However, you know you will be away from the machine on that day. 
    How will you perform the task? You can use the at utility program to execute any non-interactive command at a specified time, as illustrated in the screenshot below:
  
  <img src="images/atout.png">
  </pre>
</p><hr>


<p>
  <pre>
    <h2>cron</h2>

    cron is a time-based scheduling utility program. 
    It can launch routine background jobs at specific times and/or days on an on-going basis. cron is driven by a configuration file called /etc/crontab (cron table), 
    which contains the various shell commands that need to be run at the properly scheduled times. There are both system-wide crontab files and individual user-based ones. 
    Each line of a crontab file represents a job, and is composed of a so-called CRON expression, followed by a shell command to execute.

Typing crontab -e will open the crontab editor to edit existing jobs or to create new jobs. Each line of the crontab file will contain 6 fields:
  
<img src="images/Starting-Processes-in-the-Future-Chapter-9-Processes-Introduction-to-Linux-edX.png">

Examples:

            The entry * * * * * /usr/local/bin/execute/this/script.sh will schedule a job to execute script.sh every minute of every hour of every day of the month, and every month and every day in the week.
            The entry 30 08 10 06 * /home/sysadmin/full-backup will schedule a full-backup at 8.30 a.m., 10-June, irrespective of the day of the week.

</pre>
</p><hr>
<p><h2>anacron</h2></p>
<pre>
  While cron has been used in UNIX-like operating systems for decades, modern Linux distributions have moved over to a newer facility: anacron. 
  This was because cron implicitly assumed the machine was always running.
  However, If the machine was powered off, scheduled jobs would not run. anacron will run the necessary jobs in a controlled and staggered manner when the system is up and running.
<img src="images/anacrontab.png">
Note that anacron still makes use of the cron infrastructure for submitting jobs on a daily, 
weekly, and monthly basis, but it defers running them until opportune times when the system is actually alive.
</pre>

<p>
  <pre>
    <h2>sleep</h2>

    Sometimes, a command or job must be delayed or suspended. 
    Suppose, for example, an application has read and processed the contents of a data file and then needs to save a report on a backup system. 
    If the backup system is currently busy or not available, the application can be made to sleep (wait) until it can complete its work. 
    Such a delay might be to mount the backup device and prepare it for writing.

sleep suspends execution for at least the specified period of time, which can be given as the number of seconds (the default), minutes, hours, or days. 
After that time has passed (or an interrupting signal has been received), execution will resume.

The syntax is:

<em>sleep NUMBER[SUFFIX]...</em>

where SUFFIX may be:

            s for seconds (the default)
            m for minutes
            h for hours
            d for days.

sleep and at are quite different; sleep delays execution for a specific period, while at starts execution at a later time.
  <img src="images/sleepsuse.png">
  </pre>
</p>


<p>
  <pre>
    <h2>Using at for Batch Processing in the Future</h2>

    Schedule a very simple task to run at a future time from now. 
    This can be as simple as running ls or date and saving the output. 
    You can use a time as short as one minute in the future.

Note that the command will run in the directory from which you schedule it with at.

Do this:

            From a short bash script.
            Interactively.

<img src="images/using at for batch.png">
  </pre>
</p><hr>


<p>
  <pre>
    <h2>Scheduling a Periodic Task with cron</h2>
    Set up a cron job to do some simple task every day at 10 a.m.
    <img src="images/cron.png">
  </pre>
</p><hr>

<h3>Chapter 10 File Operations</h3>

<p>
  <pre>
    <h2>Filesystems</h2>
    In Linux (and all UNIX-like operating systems) it is often said “Everything is a file”, or at least it is treated as such. 
    This means whether you are dealing with normal data files and documents, or with devices such as sound cards and printers, 
    you interact with them through the same kind of Input/Output (I/O) operations. 
    This simplifies things: you open a “file” and perform normal operations like reading the file and writing on it (which is one reason why text editors, 
    which you will learn about in an upcoming section, are so important).

On many systems (including Linux), the filesystem is structured like a tree. The tree is usually portrayed as inverted, 
and starts at what is most often called the root directory, which marks the beginning of the hierarchical filesystem and is also sometimes referred to as the trunk, 
or simply denoted by /. The root directory is not the same as the root user. The hierarchical filesystem also contains other elements in the path (directory names),
which are separated by forward slashes (/), as in /usr/bin/emacs, where the last element is the actual file name.

In this section, you will learn about some basic concepts, including the filesystem hierarchy, as well as about disk partitions.

<img src="images/LFS01_ch08_screen_03.jpg">
  </pre>
</p><hr>


<p>
  <pre>
    <h2>Filiesystem Varieties</h2>
    Linux supports a number of native filesystem types, expressly created by Linux developers, such as:

    ext3
    ext4
    squashfs
    btrfs
    It also offers implementations of filesystems used on other alien operating systems, such as those from:
    
    Windows (ntfs, vfat, exfat)
    SGI (xfs)
    IBM (jfs)
    MacOS (hfs, hfs+)
    Many older, legacy filesystems, such as FAT, are also supported.
    
    It is often the case that more than one filesystem type is used on a machine, based on considerations such as the size of files, 
    how often they are modified, what kind of hardware they sit on and what kind of access speed is needed, etc. 
    The most advanced filesystem types in common use are the journaling varieties: ext4, xfs, btrfs, and jfs. 
    These have many state-of-the-art features and high performance, and are not easy to corrupt accidentally.
    
    Linux also makes use of network (or distributed)  filesystems, where all or part of the filesystem is on external machines.
    Besides NFS (Network File System) whose usage we will discuss, this includes Ceph, Lustre, and OpenAFS.

  </pre>
</p><hr>


<p>
  <pre>
    <h2>Linux Partitions</h2>
    Each filesystem on a Linux system occupies a disk partition. Partitions help to organize the contents of disks according to the kind and use of the data contained. 
    For example, important programs required to run the system are often kept on a separate partition (known as root or /) than the one that contains files owned by regular users of that system (/home).
    In addition, temporary files created and destroyed during the normal operation of Linux may be located on dedicated partitions. 
    One advantage of this kind of isolation by type and variability is that when all available space on a particular partition is exhausted, the system may still operate normally.

The picture shows the use of the gparted utility, which displays the partition layout on a system which has four operating systems on it: RHEL 8, CentOS 7, Ubuntu and Windows.
  
<img src="images/gparted.png">
</pre>
</p><hr>


<p>
  <pre>
    <h2>Mount Points</h2>
    Before you can start using a filesystem, you need to mount it on the filesystem tree at a mount point. 
    This is simply a directory (which may or may not be empty) where the filesystem is to be grafted on. 
    Sometimes, you may need to create the directory if it does not already exist.
  
  <img src="images/LFS01_ch08_screen06.jpg">

  </pre>
</p><hr>


<p>
  <pre>
    <h2>Mounting and Unmounting</h2>

    The mount command is used to attach a filesystem (which can be local to the computer or on a network) somewhere within the filesystem tree. The basic arguments are the device node and mount point. For example,

<em>$ sudo mount /dev/sda5 /home</em>

will attach the filesystem contained in the disk partition associated with the /dev/sda5 device node into the filesystem tree at the /home mount point. 
There are other ways to specify the partition other than the device node, such as using the disk label or UUID.

To unmount the partition, the command would be:

<em>$ sudo umount /home</em>

Note the command is umount, not unmount! Only a root user (logged in as root, or using sudo) has the privilege to run these commands, unless the system has been otherwise configured.

If you want it to be automatically available every time the system starts up, you need to edit /etc/fstab accordingly (the name is short for filesystem table). 
Looking at this file will show you the configuration of all pre-configured filesystems. man fstab will display how this file is used and how to configure it.


Executing mount without any arguments will show all presently mounted filesystems.


The command df -Th (disk-free) will display information about mounted filesystems, including the filesystem type, and usage statistics about currently used and available space.
  
<img src="images/dfmountdebian.png">
</pre>
</p><hr>


<p>
  <pre>
    <h2>NFS and Network Filesystems</h2>
    It is often necessary to share data across physical systems which may be either in the same location or anywhere that can be reached by the Internet. 
    A network (also sometimes called distributed) filesystem may have all its data on one machine or have it spread out on more than one network node. 
    A variety of different filesystems can be used locally on individual machines; 
    a network filesystem can be thought of as a grouping of lower-level filesystems of varying types.
  
    <img src="images/NFS_LFS101.png" width="40%" height="40%">

                        The Client-Server Architecture of NFS
                      (based on the original from <a href="https://developer.ibm.com/tutorials/l-network-filesystems/" target="_blank">www.ibm.com</a>)

Many system administrators mount remote users' home directories on a server in order to give them access to the same files and configuration files across multiple client systems.
This allows the users to log in to different computers, yet still have access to the same files and resources.

The most common such filesystem is named simply NFS (the Network Filesystem). It has a very long history and was first developed by Sun Microsystems. 
Another common implementation is CIFS (also termed SAMBA), which has Microsoft roots. We will restrict our attention in what follows to NFS.
</pre>
</p><hr>


<p>
  <pre>
    <h2>NFS on the Server</h2>

    We will now look in detail at how to use NFS on the server.

On the server machine, NFS uses daemons (built-in networking and service processes in Linux) and other system servers are started at the command line by typing:

$ sudo systemctl start nfs

NOTE: On some systems, such as RHEL/CentOS, and Fedora, the service is now called nfs-server, not nfs.

The text file /etc/exports contains the directories and permissions that a host is willing to share with other systems over NFS. 
A very simple entry in this file may look like the following:

/projects *.example.com(rw)

This entry allows the directory /projects to be mounted using NFS with read and write (rw) permissions and shared with other hosts in the example.com domain. 
As we will detail in the next chapter, every file in Linux has three possible permissions: read (r), write (w) and execute (x).

After modifying the /etc/exports file, you can type exportfs -av to notify Linux about the directories you are allowing to be remotely mounted using NFS. 
You can also restart NFS with sudo systemctl restart nfs, but this is heavier, as it halts NFS for a short while before starting it up again. 
To make sure the NFS service starts whenever the system is booted, issue sudo systemctl enable nfs.
  
<img src="images/exportsnfs.png">
</pre>
</p><hr>


<p>
  <pre>
    <h2>NFS on the Client</h2>

    On the client machine, if it is desired to have the remote filesystem mounted automatically upon system boot, /etc/fstab is modified to accomplish this. 
    For example, an entry in the client's /etc/fstab might look like the following:

servername:/projects /mnt/nfs/projects nfs defaults 0 0

You can also mount the remote filesystem without a reboot or as a one-time mount by directly using the mount command:

$ sudo mount servername:/projects /mnt/nfs/projects

Remember, if /etc/fstab is not modified, this remote mount will not be present the next time the system is restarted. 
Furthermore, you may want to use the nofail option in fstab in case the NFS server is not live at boot.
  
<img src="images/nfsclientubuntu.png">
</pre>
</p><hr>


<p>
  <pre>
    <h2> Exploring Mounted Filesystems</h2>

    Issue the command:

student:/tmp> cat /etc/fstab

Now type:

student:/tmp> mount

Compare the results. What are the differences?

Find another way to see a list of the mounted filesystems, by examining the /proc pseudo-filesystem.



Typically, mount will show more filesystems mounted than are shown in /etc/fstab, which only lists those which are explicitly requested.

The system, however, will mount additional special filesystems required for normal operation, which are not enumerated in /etc/fstab.

Another way to show mounted filesystems is to type:

student:/tmp> cat /proc/mounts

which is essentially how the utility gets its information.
  </pre>
</p><hr>


<p>
  <pre>
    <h2>Overview of User Home Directories</h2>

    In this section, you will learn to identify and differentiate between the most important directories found in Linux. 
    We start with ordinary users' home directory space.

Each user has a home directory, usually placed under /home. The /root ("slash-root") directory on modern 
Linux systems is no more than the home directory of the root user (or superuser or system administrator account).

On multi-user systems, the /home directory infrastructure may be mounted as a separate filesystem on its own partition 
or even exported (shared) remotely on a network through NFS.

Sometimes, you may group users based on their department or function. You can then create subdirectories under the
/home directory for each of these groups. For example, a school may organize /home with something like the following:

/home/faculty/
/home/staff/
/home/students/

<img src="images/asset-v1_LinuxFoundationX+LFS101x+1T2023+type@asset+block@LFS101x_2023_CourseImages_10-13-02.png">

  </pre>
</p><hr>


<p>
  <pre>
    <h2>The /bin and /sbin Directories</h2>

    The /bin directory contains executable binaries, essential commands used to boot the system or in single-user mode,
    and essential commands required by all system users, such as cat, cp, ls, mv, ps, and rm.

    <img src="images/lsbin.png">
    Likewise, the /sbin directory is intended for essential binaries related to system administration, such as fsck and ip. 
    To view a list of these programs, type:

    $ ls /bin /sbin   


    <img src="images/lssbin.png">

    Commands that are not essential (theoretically) for the system to boot or operate in single-user mode are placed in the /usr/bin and /usr/sbin directories. 
    Historically, this was done so /usr could reside on a separate filesystem that could be mounted at a later stage of system startup or even over a network. 
    However, nowadays most find this distinction to be obsolete. In fact, many distributions have been discovered to be unable to boot with this separation, 
    as this modality had not been used or tested for a long time.

Thus, on most Linux distributions today, /usr/bin and /bin are actually just symbolically linked together, as are /usr/sbin and /sbin, 
so there are really just two directories, not four.
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>


<p>
  <pre>
    <h2></h2>
  </pre>
</p>





































